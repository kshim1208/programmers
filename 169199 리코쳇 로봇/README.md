## 리코쳇 로봇
  
### 사용한 접근 방식
최단 거리를 찾는 과제이기에 BFS를 선택했다.  
DFS는 깊이 우선이라 최단 거리가 존재하지 않는 노드 조합을 탐색하여 비효율적인 동작을 할 가능성이 있었음.  
또한 최단 거리는 트리의 깊이이므로, 해당 깊이에서의 가능한 경우를 확인한 뒤 넘어가는데 최단 거리를 찾기 더 유리하다고 생각함.  
  
### 공부한 것
BFS 전반  
4방향 이동을 반복문으로 표현하는 법 - 하나의 iter 구조로 묶어내기
pair 클래스 사용법 - map이나 set에서 간접적으로 썼었는데, 이게 클래스 단위로 존재하는 줄은 처음 알았음.  
queue container adaptor 사용법  
- container adaptor이기에 stack처럼 기반이 되는 container의 기능을 가져와서 사용.  
- 그 과정에서 이름이 약간 달라진 경우 있었음. push_back 대신 push를 쓴다던가.  
일부 container의 멤버 함수를 재확인했음. 특히 pair를 공부하는 과정에서 set과 map의 구조를 다시 한 번 점검함.  
  

### 겪었던 문제와 해결
전체 보드를 따로 관리할지 고민을 좀 했었다.  
DFS의 경우, 특정 재귀 상태에서 내가 어느 방향으로 이동한 이력이 있는지 따로 보관할 필요가 있었다.  
그래서 전체 구조가 필요할지도 모른다고 생각했었는데, BFS는 그럴 필요가 없을 것으로 결론내렸다.  
왜냐하면 특정 depth에서 이동한 결과를 전부 queue나 그에 준하는 자료 구조에 추가해둘 수 있기 때문이다.  
그래서 방문 여부만 저장하는 배열을 두고, 각 방향에 대한 이동을 queue에 집어넣었다.  
